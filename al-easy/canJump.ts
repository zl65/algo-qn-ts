function canJump(nums: number[]): boolean {
  let max = 0
  for (let i = 0; i < nums.length; i++) {
    if (i > max) return false

    max = Math.max(max, i + nums[i])
    if (max >= nums.length - 1) return true
  }
  return false
}

// 思路一，从后往前推
// 最开始没想通的是，那每一个点都会有非常多的点能到达，这都要计算的话，这循环要怎么写很困难
// 但实际上，从前往后，只有第一个能到达目标点的有意义，后边都不用看了
// 比如 abc 按顺序都能到达，那只要进入下一个递归，终点变成 a 就好了
// 因为能到 a 就能到达终点，不能到达 a，那 bc 也到不了
// 这个题的关键就是每次都是一步一步走的，每步之间没有约束，所以相当于减少了很多情况


// 思路二，从前往后推， dp[i]表示能到达这个点
// 每次看一个点最远能到哪里，然后把从这个点到最远的点之间的所有 dp 值设为 true
// 到这之后的困惑是既要遍历原数组，又要遍历 dp，这俩到底啥关系，怎么算
// 实际上不用遍历原数组，只要遍历 dp，就是当前能到达的所有点，过程中发现 dp[i]里的i已经大于原数组长度了，就可以结束

// 其实这个思路再往下做空间优化，就是答案
